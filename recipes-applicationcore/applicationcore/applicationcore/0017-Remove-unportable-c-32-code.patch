From 834b4d206ecab275493dc557d69aa1765fdfe84f Mon Sep 17 00:00:00 2001
From: Jens Georg <jens.georg@desy.de>
Date: Thu, 26 Jun 2025 19:07:34 +0200
Subject: [PATCH] Remove unportable c++32 code

---
 Python/bindings/src/PythonBindings.cc        |   4 +-
 src/ConnectionMaker.cc                       |   6 +-
 tests/executables_src/testReverseRecovery.cc | 466 -------------------
 3 files changed, 7 insertions(+), 469 deletions(-)
 delete mode 100644 tests/executables_src/testReverseRecovery.cc

diff --git a/Python/bindings/src/PythonBindings.cc b/Python/bindings/src/PythonBindings.cc
index 9e89aa0..e0df630 100644
--- a/Python/bindings/src/PythonBindings.cc
+++ b/Python/bindings/src/PythonBindings.cc
@@ -34,6 +34,8 @@
 #include <string>
 #include <variant>
 
+#include <fmt/format.h>
+
 namespace py = pybind11;
 using namespace py::literals;
 
@@ -145,7 +147,7 @@ namespace ChimeraTK {
         .def("__bool__", [](Boolean& v) { return bool(v); })
         .def("__repr__", [](Boolean& v) { return "Boolean(" + std::to_string(bool(v)) + ")"; })
         .def("__int__", [](Boolean& v) { return int(bool(v)); })
-        .def("__str__", [](Boolean& v) { return std::format("{}", bool(v)); });
+        .def("__str__", [](Boolean& v) { return fmt::format("{}", bool(v)); });
 
     /**
      * TransferElementID
diff --git a/src/ConnectionMaker.cc b/src/ConnectionMaker.cc
index a17c963..ec5b7e4 100644
--- a/src/ConnectionMaker.cc
+++ b/src/ConnectionMaker.cc
@@ -20,6 +20,8 @@
 
 #include <algorithm>
 
+#include <fmt/format.h>
+
 namespace ChimeraTK {
 
   /*********************************************************************************************************************/
@@ -902,7 +904,7 @@ namespace ChimeraTK {
       }
     }
     else if(net.consumers.size() > 1) {
-      debug(std::format("  More than one consumer, using fan-out as feeder impl (with return: {})",
+      debug(fmt::format("  More than one consumer, using fan-out as feeder impl (with return: {})",
           net.feeder.getDirection().withReturn));
       callForType(*net.valueType, [&](auto t) {
         using UserType = decltype(t);
@@ -985,7 +987,7 @@ namespace ChimeraTK {
           // We need to promote the accessor with the reverse recovery tag to the network feeder
           // to prevent writing down the constant value into the device and propagating the
           // recovery value to the other consumers instead.
-          auto reverseConsumer = std::ranges::find_if(network.consumers, [](auto& consumer) {
+          auto reverseConsumer = std::find_if(network.consumers.begin(), network.consumers.end(), [](auto& consumer) {
             return consumer.getType() == NodeType::Device &&
                 consumer.getTags().contains(ChimeraTK::SystemTags::reverseRecovery);
           });
diff --git a/tests/executables_src/testReverseRecovery.cc b/tests/executables_src/testReverseRecovery.cc
deleted file mode 100644
index 7953b10..0000000
--- a/tests/executables_src/testReverseRecovery.cc
+++ /dev/null
@@ -1,466 +0,0 @@
-// SPDX-FileCopyrightText: Deutsches Elektronen-Synchrotron DESY, MSK, ChimeraTK Project <chimeratk-support@desy.de>
-// SPDX-License-Identifier: LGPL-3.0-or-later
-#include "ScalarAccessor.h"
-
-#include <ChimeraTK/DeviceBackend.h>
-#include <ChimeraTK/ReadAnyGroup.h>
-#include <ChimeraTK/SharedDummyBackend.h>
-#include <ChimeraTK/TransferElement.h>
-#include <ChimeraTK/VoidRegisterAccessor.h>
-
-#include <boost/smart_ptr/shared_ptr.hpp>
-
-#define BOOST_TEST_MODULE reverseRecoveryTest
-
-#include "Application.h"
-#include "ApplicationModule.h"
-#include "check_timeout.h"
-#include "DeviceModule.h"
-#include "Logger.h"
-#include "ScalarAccessor.h"
-#include "TestFacility.h"
-
-#include <ChimeraTK/BackendFactory.h>
-#include <ChimeraTK/Device.h>
-
-#include <boost/test/included/unit_test.hpp>
-
-#include <cstdint>
-
-namespace ctk = ChimeraTK;
-
-struct TestApplication : ctk::Application {
-  TestApplication() : ctk::Application("tagTestApplication") { debugMakeConnections(); }
-  ~TestApplication() override { shutdown(); }
-
-  struct : public ctk::ApplicationModule {
-    using ctk::ApplicationModule::ApplicationModule;
-
-    std::function<void()> doMainLoop;
-
-    void mainLoop() final { doMainLoop(); }
-  } mod{this, "Module", ""};
-};
-
-/********************************************************************************************************************/
-
-BOOST_AUTO_TEST_CASE(testDirectThreadedFanOutWithReturn) {
-  std::cout << "testDirectThreadedFanOutWithReturn" << std::endl;
-
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/readWrite", 4);
-  dev.write<int32_t>("/writeOnlyRB.DUMMY_WRITEABLE", 8);
-  dev.write<int32_t>("/secondReadWrite", 16);
-
-  // Set initial values for the variables
-  test.setScalarDefault<int32_t>("/taggedReadWrite", 12);
-  test.setScalarDefault<int32_t>("/taggedWriteOnly", 24);
-  test.setScalarDefault<int32_t>("/untagged", 36);
-
-  test.runApplication();
-
-  // Wait for the device to become ready
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  up.wait(false);
-
-  auto taggedReadWriteCs = test.getScalar<int32_t>("/taggedReadWrite");
-  auto taggedWriteOnlyCs = test.getScalar<int32_t>("/taggedWriteOnly");
-  auto untagged = test.getScalar<int32_t>("/untagged");
-
-  // Check that the values are still on the values we have written explicitly
-  // into the device, and not the initial values we configured above
-  BOOST_TEST(dev.read<int32_t>("/readWrite") == 4);
-  BOOST_TEST(dev.read<int32_t>("/writeOnlyRB") == 8);
-
-  // Check that instead those values have been propagated to the CS (where applicable)
-  CHECK_EQUAL_TIMEOUT((taggedReadWriteCs.readLatest(), int(taggedReadWriteCs)), 4, 2000);
-
-  // The untagged register should have received the initial value from the CS
-  BOOST_TEST(dev.read<int32_t>("/secondReadWrite") == 36);
-
-  // Just do normal operations
-  taggedReadWriteCs.setAndWrite(48);
-  taggedWriteOnlyCs.setAndWrite(96);
-  untagged.setAndWrite(128);
-
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 48, 2000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/writeOnlyRB"), 96, 2000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 128, 2000);
-
-  dev.write<int32_t>("/readWrite", 3);
-  dev.write<int32_t>("/writeOnlyRB.DUMMY_WRITEABLE", 7);
-  dev.write<int32_t>("/secondReadWrite", 15);
-  devModule.reportException("Trigger device recovery");
-
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  // The two tagged registers should keep their values, the untagged register should receive the value written before
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 3, 1000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/writeOnlyRB"), 7, 1000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 128, 1000);
-
-  // The read-write register should have propagated its value to the CS
-  CHECK_EQUAL_TIMEOUT((taggedReadWriteCs.readLatest(), int32_t(taggedReadWriteCs)), 3, 2000);
-
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Create a ThreadedFanOutWithReturn and check that we can use the
-// just the recovery value as an input
-BOOST_AUTO_TEST_CASE(testThreadedFanOutWithReturnOnlyRecoverValue) {
-  std::cout << "testThreadedFanOutWithReturnOnlyRecoverValue" << std::endl;
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/readWrite", 4);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarPushInput<int32_t> deviceInput{&app.mod, "/taggedReadWrite", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  // Set initial values for the variables
-  test.setScalarDefault<int32_t>("/taggedReadWrite", 12);
-
-  test.runApplication();
-  up.wait(false);
-
-  // Check that the device did not receive the initial value in this setup
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 4, 1000);
-
-  // Check that the input is having the value from the device
-  CHECK_EQUAL_TIMEOUT(deviceInput, 4, 1000);
-
-  dev.write<int32_t>("/readWrite", 8);
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  deviceInput.read();
-  CHECK_EQUAL_TIMEOUT(int32_t(deviceInput), 8, 1000);
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Force the connection maker to create a direct connection with constant
-// feeder
-BOOST_AUTO_TEST_CASE(testConstantFeederInversion) {
-  std::cout << "testConstantFeederInversion" << std::endl;
-
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/readWrite", 4);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarPushInput<int32_t> deviceInput{&app.mod, "/taggedReadWrite", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  app.optimiseUnmappedVariables({"/taggedReadWrite"});
-  test.runApplication();
-  up.wait(false);
-
-  CHECK_EQUAL_TIMEOUT(int32_t(deviceInput), 4, 1000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 4, 1000);
-
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  deviceInput.read();
-  CHECK_EQUAL_TIMEOUT(int32_t(deviceInput), 4, 1000);
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Have an application module that has an explicit accessor requesting reverse recovery
-BOOST_AUTO_TEST_CASE(testFeedingFanOutWithExplicitAccessor) {
-  std::cout << "testFeedingFanOutWithExplicitAccessor" << std::endl;
-
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/readWrite", 4);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarOutputReverseRecovery<int32_t> deviceInput{&app.mod, "/taggedReadWrite", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  test.runApplication();
-  up.wait(false);
-
-  CHECK_EQUAL_TIMEOUT((int32_t(deviceInput)), 4, 1000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 4, 1000);
-
-  // Check that we can still write down to the device properly
-  deviceInput.setAndWrite(44);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 44, 1000);
-
-  // Manipulate the device so we can check that the value is propagated
-  // from the device to the application, as expected, after the device recovers
-  dev.write<int32_t>("/readWrite", 111);
-
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  deviceInput.read();
-  CHECK_EQUAL_TIMEOUT(int32_t(deviceInput), 111, 1000);
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Have an application module that has an explicit accessor requesting reverse recovery
-BOOST_AUTO_TEST_CASE(testFanOutWithExplicitAccessor02) {
-  std::cout << "testFanOutWithExplicitAccessor02" << std::endl;
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/readWrite", 4);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarOutputReverseRecovery<int32_t> deviceInput{&app.mod, "/taggedReadWrite", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  app.optimiseUnmappedVariables({"/taggedReadWrite"});
-  test.runApplication();
-  up.wait(false);
-
-  CHECK_EQUAL_TIMEOUT((int32_t(deviceInput)), 4, 1000);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 4, 1000);
-
-  // Check that we can still write down to the device properly
-  deviceInput.setAndWrite(44);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/readWrite"), 44, 1000);
-
-  // Manipulate the device so we can check that the value is propagated
-  // from the device to the application, as expected, after the device recovers
-  dev.write<int32_t>("/readWrite", 111);
-
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  deviceInput.read();
-  CHECK_EQUAL_TIMEOUT(int32_t(deviceInput), 111, 1000);
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Request that we do the reverse recovery from an untagged device register by using the ReverseRecovery accessor
-BOOST_AUTO_TEST_CASE(testReverseRecoveryFromApp) {
-  std::cout << "testReverseRecoveryFromApp" << std::endl;
-
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/secondReadWrite", 815);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarOutputReverseRecovery<int32_t> deviceInput{&app.mod, "/untagged", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-  test.setScalarDefault("/untagged", 4711);
-
-  test.runApplication();
-
-  // Wait for the device to become ready
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  up.wait(false);
-  auto untagged = test.getScalar<int32_t>("/untagged");
-
-  BOOST_TEST(dev.read<int32_t>("/secondReadWrite") == 815);
-
-  deviceInput.setAndWrite(128);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 128, 2000);
-
-  dev.write<int32_t>("/secondReadWrite", 3);
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 3, 2000);
-
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-BOOST_AUTO_TEST_CASE(testRecoveryFromAppDirect) {
-  std::cout << "testReverseRecoveryFromApp" << std::endl;
-
-  ctk::BackendFactory::getInstance().setDMapFilePath("testTagged.dmap");
-
-  ctk::Device dev;
-  dev.open("baseDevice");
-
-  // Initialize the device with some values
-  dev.write<int32_t>("/secondReadWrite", 815);
-
-  TestApplication app;
-  ctk::DeviceModule devModule{&app, "taggedDevice", "/trigger"};
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarOutputReverseRecovery<int32_t> deviceInput{&app.mod, "/untagged", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-  test.setScalarDefault("/untagged", 4711);
-  app.optimiseUnmappedVariables({"/untagged"});
-  test.runApplication();
-
-  // Wait for the device to become ready
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  up.wait(false);
-  auto untagged = test.getScalar<int32_t>("/untagged");
-
-  BOOST_TEST(dev.read<int32_t>("/secondReadWrite") == 815);
-
-  deviceInput.setAndWrite(128);
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 128, 2000);
-
-  dev.write<int32_t>("/secondReadWrite", 3);
-  devModule.reportException("Trigger device recovery");
-
-  // Wait for ApplicationCore to recover
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 1, 1000);
-  CHECK_EQUAL_TIMEOUT(test.readScalar<int32_t>("/Devices/taggedDevice/status"), 0, 1000);
-
-  CHECK_EQUAL_TIMEOUT(dev.read<int32_t>("/secondReadWrite"), 3, 2000);
-
-  app.shutdown();
-}
-
-/********************************************************************************************************************/
-
-// Special case: Reverse recovery, but without any device
-BOOST_AUTO_TEST_CASE(testReverseRecoveryFromCS) {
-  std::cout << "testReverseRecoveryFromCS" << std::endl;
-  TestApplication app;
-
-  std::atomic<bool> up{false};
-
-  ctk::ScalarOutputReverseRecovery<int32_t> csOutput{&app.mod, "/taggedReadWrite", "", ""};
-
-  app.mod.doMainLoop = [&]() {
-    up = true;
-    up.notify_one();
-  };
-
-  ctk::TestFacility test(app, false);
-
-  test.setScalarDefault("/taggedReadWrite", 4711);
-
-  test.runApplication();
-  up.wait(false);
-
-  CHECK_EQUAL_TIMEOUT(csOutput, 4711, 2000);
-
-  app.shutdown();
-}
